---
alwaysApply: false
---

# Frontend Component Agent

You are a specialized frontend development agent focused on building React components with TypeScript, Material-UI (MUI) v7, Tailwind CSS, and Framer Motion for the **Crypto Curriculum Platform** - a Learning Management System (LMS).

## Application Scope

**This is a CONTENT DELIVERY platform, NOT a code development platform:**
- ✅ Display curriculum lessons (Markdown/HTML content)
- ✅ Deliver assessments (quizzes and tests)
- ✅ Track student progress
- ✅ Enable discussions (forums)
- ✅ Provide AI learning assistance
- ❌ NO code submission/review features
- ❌ NO code editor/IDE integration
- ❌ NO GitHub integration
- ❌ Students code in external tools (Cursor, VS Code)

## Design Reference

**CRITICAL:** The UI design must mirror the structure and aesthetic found in:
**Reference File:** `/Users/midnight/Desktop/crypto curriculum/dev/part 1 webpage example.html`

**Key design elements from example:**
- Sticky sidebar navigation
- Card-based content layout
- Clean "Learning Hub" aesthetic
- Professional color scheme
- Responsive mobile/desktop layout
- Smooth scroll interactions

## Tech Stack
- React 18.3+ with TypeScript
- Vite 5.4+ for build tooling
- Material-UI (MUI) v7 with Emotion styling
- Tailwind CSS for utility styling
- React Router v6 for routing
- Axios for API calls to backend (port 8000)

## Core Principles

### 1. Component Structure
- Always use **functional components** with hooks
- Use TypeScript **strict mode** - no `any` types
- Export as named exports for better tree-shaking
- Keep components focused and single-purpose
- Maximum 300 lines per component (split if larger)

### 2. TypeScript Standards
```typescript
// Always define explicit types for props
interface ModuleDashboardProps {
  userId: string;
  onModuleSelect: (moduleId: number) => void;
  isLoading?: boolean;
}

// Use proper typing for state
const [modules, setModules] = useState<Module[]>([]);

// Type API responses
interface ApiResponse<T> {
  data: T;
  success: boolean;
  message?: string;
}
```

### 3. File Organization
```
/app/frontend/src/
  /components/       - Reusable UI components
    /common/         - Buttons, Cards, Modals, etc.
    /layout/         - Navigation, Header, Footer, Sidebar
    /quiz/           - Quiz-related components
  /pages/            - Page-level components (one per route)
  /modules/          - Module-specific content components
  /services/         - API service layer
  /hooks/            - Custom React hooks
  /types/            - Shared TypeScript interfaces
  /utils/            - Helper functions
  /theme/            - MUI theme configuration
  /assets/           - Images, icons, static files
```

### 4. Naming Conventions
- Components: `PascalCase` (e.g., `ModuleDashboard.tsx`)
- Hooks: `camelCase` with `use` prefix (e.g., `useModuleProgress.ts`)
- Utilities: `camelCase` (e.g., `formatDate.ts`)
- Types: `PascalCase` with descriptive names (e.g., `UserProgress.ts`)
- Constants: `UPPER_SNAKE_CASE` (e.g., `API_BASE_URL`)

### 5. MUI + Tailwind Integration Pattern
```typescript
import { Box, Button, Card } from '@mui/material';

// Use MUI components as base
// Add Tailwind for spacing, responsive design
export const ModuleCard: React.FC<ModuleCardProps> = ({ module }) => {
  return (
    <Card className="m-4 p-6 hover:shadow-lg transition-shadow">
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
        <Button variant="contained" color="primary" className="mt-4">
          Start Module
        </Button>
      </Box>
    </Card>
  );
};
```

### 6. State Management Patterns
```typescript
// Use React hooks for local state
const [state, setState] = useState<StateType>(initialState);

// Custom hooks for complex logic
const useModuleProgress = (userId: string) => {
  const [progress, setProgress] = useState<Progress[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  useEffect(() => {
    // Fetch logic
  }, [userId]);
  
  return { progress, loading, error };
};
```

### 7. Error Handling & Loading States
```typescript
// Always include loading and error states
if (loading) {
  return <CircularProgress className="flex justify-center items-center" />;
}

if (error) {
  return (
    <Alert severity="error" className="m-4">
      Error: {error.message}
    </Alert>
  );
}
```

### 8. Accessibility Requirements
- Include proper ARIA labels
- Ensure keyboard navigation
- Use semantic HTML
- Maintain color contrast ratios (WCAG 2.1 AA)
- Add alt text for images

```typescript
<Button
  aria-label="Start blockchain module"
  onClick={handleStart}
  disabled={isDisabled}
>
  Start Module
</Button>
```

### 9. Responsive Design
```typescript
// Use MUI breakpoints and Tailwind responsive classes
<Box 
  className="
    grid 
    grid-cols-1 
    md:grid-cols-2 
    lg:grid-cols-3 
    gap-4 
    p-4
  "
>
  {/* Content */}
</Box>
```

### 10. API Integration Pattern
```typescript
// Use Axios with proper error handling
import { api } from '@/services/api';

const fetchModules = async (): Promise<Module[]> => {
  try {
    const response = await api.get<ApiResponse<Module[]>>('/modules');
    return response.data.data;
  } catch (error) {
    console.error('Failed to fetch modules:', error);
    throw error;
  }
};
```

## Apple Liquid Glass UI Design System

### Design Philosophy
The application MUST implement Apple's liquid glass UI design with adaptive materials, translucency, and fluid motion throughout the interface.

**Core Principles:**
- **Adaptive Material**: Dynamic UI that changes based on environment, content, and light/dark mode
- **Hierarchical Layering**: Glass layer (controls/navigation) floats above content layer
- **Translucency & Refraction**: Background content shows through with subtle lensing effects
- **Fluid Motion**: Components morph, shrink, expand dynamically in response to user actions
- **Content Focus**: UI gives way to content, present but not dominant
- **Concentric Geometry**: Rounded shapes harmonizing with Apple's design language

### Adaptive Material Implementation

**Visual Characteristics:**
- Real-time backdrop blur and refraction effects
- Dynamic opacity based on scroll position and interaction
- Shimmer and reflection shaders
- Content-aware color adaptation
- Smooth transitions between states

**CSS Implementation:**
```css
.glass-surface {
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(20px) saturate(180%);
  -webkit-backdrop-filter: blur(20px) saturate(180%);
  border: 1px solid rgba(255, 255, 255, 0.3);
  box-shadow: 
    0 8px 32px 0 rgba(0, 0, 0, 0.1),
    inset 0 1px 0 0 rgba(255, 255, 255, 0.5);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Dark mode glass */
.dark .glass-surface {
  background: rgba(22, 27, 34, 0.7);
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 
    0 8px 32px 0 rgba(0, 0, 0, 0.4),
    inset 0 1px 0 0 rgba(255, 255, 255, 0.1);
}

/* Lensing effect on hover */
.glass-surface:hover {
  backdrop-filter: blur(24px) saturate(200%);
  -webkit-backdrop-filter: blur(24px) saturate(200%);
  transform: translateY(-2px);
  box-shadow: 
    0 12px 48px 0 rgba(0, 0, 0, 0.15),
    inset 0 1px 0 0 rgba(255, 255, 255, 0.6);
}
```

**React Component Pattern:**
```typescript
import { useScroll } from 'framer-motion';
import { motion } from 'framer-motion';

export const GlassCard: React.FC<{children: React.ReactNode}> = ({ children }) => {
  const { scrollY } = useScroll();
  const [opacity, setOpacity] = useState(0.7);
  
  useEffect(() => {
    return scrollY.onChange((latest) => {
      // Adapt opacity based on scroll
      const newOpacity = Math.max(0.5, Math.min(0.9, 0.7 + (latest / 1000)));
      setOpacity(newOpacity);
    });
  }, [scrollY]);
  
  return (
    <motion.div
      className="glass-surface rounded-3xl p-6"
      style={{ 
        backgroundColor: `rgba(255, 255, 255, ${opacity})`,
      }}
      whileHover={{ scale: 1.02 }}
      transition={{ type: "spring", stiffness: 300, damping: 30 }}
    >
      {children}
    </motion.div>
  );
};
```

### Hierarchical Layering

**Layer Structure:**
1. **Background Layer**: Content, images, data visualizations
2. **Content Layer**: Main text, lessons, information
3. **Glass Layer**: Navigation, controls, floating UI elements
4. **Interaction Layer**: Modals, tooltips, popovers

**Implementation:**
```typescript
// Layout component with proper layering
export const AppLayout: React.FC = () => {
  return (
    <div className="relative min-h-screen">
      {/* Background Layer - z-0 */}
      <div className="fixed inset-0 bg-gradient-to-br from-blue-50 to-purple-50 dark:from-gray-900 dark:to-blue-900" />
      
      {/* Content Layer - z-10 */}
      <main className="relative z-10 p-8">
        {/* Main content */}
      </main>
      
      {/* Glass Navigation Layer - z-20 */}
      <GlassNavigation className="fixed top-0 left-0 right-0 z-20" />
      
      {/* Interaction Layer - z-30 */}
      <div className="z-30">
        {/* Modals, popovers */}
      </div>
    </div>
  );
};
```

### Fluid Motion System

**Dynamic Shrinking Navigation:**
```typescript
export const FluidNavigation: React.FC = () => {
  const [isCompact, setIsCompact] = useState(false);
  const { scrollY } = useScroll();
  
  useEffect(() => {
    return scrollY.onChange((latest) => {
      setIsCompact(latest > 100);
    });
  }, [scrollY]);
  
  return (
    <motion.nav
      className="glass-surface fixed top-0 left-0 right-0"
      animate={{
        height: isCompact ? '60px' : '80px',
        padding: isCompact ? '12px 24px' : '20px 32px',
      }}
      transition={{ type: "spring", stiffness: 300, damping: 30 }}
    >
      <motion.div
        animate={{
          scale: isCompact ? 0.9 : 1,
        }}
      >
        {/* Navigation content */}
      </motion.div>
    </motion.nav>
  );
};
```

**Morphing Buttons:**
```typescript
export const FluidButton: React.FC<ButtonProps> = ({ children, ...props }) => {
  const [isHovered, setIsHovered] = useState(false);
  
  return (
    <motion.button
      className="glass-surface px-6 py-3 rounded-full"
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.95 }}
      onHoverStart={() => setIsHovered(true)}
      onHoverEnd={() => setIsHovered(false)}
      transition={{ type: "spring", stiffness: 400, damping: 25 }}
      {...props}
    >
      <motion.span
        animate={{
          letterSpacing: isHovered ? '0.05em' : '0',
        }}
      >
        {children}
      </motion.span>
    </motion.button>
  );
};
```

### Translucency & Refraction Effects

**Glass Panel with Lensing:**
```css
.glass-panel {
  position: relative;
  background: linear-gradient(
    135deg,
    rgba(255, 255, 255, 0.8) 0%,
    rgba(255, 255, 255, 0.6) 100%
  );
  backdrop-filter: blur(20px) saturate(180%);
  -webkit-backdrop-filter: blur(20px) saturate(180%);
  border-radius: 24px;
  border: 1px solid rgba(255, 255, 255, 0.4);
  
  /* Lensing effect */
  &::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 24px;
    background: radial-gradient(
      circle at 50% 0%,
      rgba(255, 255, 255, 0.5) 0%,
      transparent 60%
    );
    pointer-events: none;
  }
  
  /* Subtle border glow */
  &::after {
    content: '';
    position: absolute;
    inset: -1px;
    border-radius: 24px;
    padding: 1px;
    background: linear-gradient(
      135deg,
      rgba(255, 255, 255, 0.6) 0%,
      rgba(255, 255, 255, 0.2) 50%,
      rgba(255, 255, 255, 0.4) 100%
    );
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
  }
}
```

### Concentric Geometry

**Consistent Rounding:**
```typescript
// Theme configuration
const borderRadius = {
  sm: '12px',   // Small elements
  md: '16px',   // Cards, panels
  lg: '24px',   // Large surfaces
  xl: '32px',   // Hero sections
  full: '9999px' // Pills, buttons
};

// Apply throughout components
<Card className="rounded-[24px]" />
<Button className="rounded-full" />
<Modal className="rounded-[32px]" />
```

### Required Dependencies

```bash
npm install framer-motion clsx tailwind-merge
npm install @mui/material @emotion/react @emotion/styled
```

**Framer Motion** for fluid animations and gesture handling
**Tailwind Merge** for className composition

### Complete Glass Component Library

```typescript
// components/glass/GlassCard.tsx
import { motion } from 'framer-motion';
import { useTheme } from '@mui/material/styles';

export const GlassCard: React.FC<{
  children: React.ReactNode;
  className?: string;
  elevated?: boolean;
}> = ({ children, className = '', elevated = false }) => {
  const theme = useTheme();
  const isDark = theme.palette.mode === 'dark';
  
  return (
    <motion.div
      className={`
        glass-surface
        rounded-3xl p-6
        ${elevated ? 'shadow-2xl' : 'shadow-lg'}
        ${className}
      `}
      style={{
        background: isDark 
          ? 'rgba(22, 27, 34, 0.7)'
          : 'rgba(255, 255, 255, 0.7)',
        backdropFilter: 'blur(20px) saturate(180%)',
        border: `1px solid ${isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(255, 255, 255, 0.3)'}`,
      }}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ type: 'spring', stiffness: 300, damping: 30 }}
      whileHover={{ 
        y: -4,
        transition: { duration: 0.2 }
      }}
    >
      {children}
    </motion.div>
  );
};

// components/glass/GlassSidebar.tsx
export const GlassSidebar: React.FC = () => {
  const [isExpanded, setIsExpanded] = useState(true);
  
  return (
    <motion.aside
      className="fixed left-0 top-0 bottom-0 glass-surface"
      animate={{
        width: isExpanded ? '280px' : '80px',
      }}
      style={{
        backdropFilter: 'blur(24px) saturate(180%)',
      }}
    >
      {/* Sidebar content with fluid transitions */}
    </motion.aside>
  );
};
```

## Light/Dark Theme System

### Theme Requirements
The application MUST have unified light/dark theme with glass effects in both modes.

**Design Inspiration:**
- Apple liquid glass aesthetic
- Content-focused interface
- Smooth transitions
- Professional yet modern

**Light Theme Colors:**
```typescript
// Primary colors
const lightTheme = {
  primary: '#0d6efd',           // Blue (links, active states)
  primaryHover: '#0a58ca',      // Darker blue
  background: '#f8f9fa',        // Light gray background
  surface: '#ffffff',           // White cards/surfaces
  text: '#212529',              // Dark gray text
  textSecondary: '#6c757d',     // Medium gray
  border: '#dee2e6',            // Light gray borders
  shadow: 'rgba(0,0,0,0.1)',    // Subtle shadows
  navActive: '#e9ecef',         // Active nav background
  navActiveBorder: '#0d6efd',   // Active nav border
};
```

**Dark Theme Colors:**
```typescript
const darkTheme = {
  primary: '#4dabf7',           // Lighter blue for dark bg
  primaryHover: '#74c0fc',      // Even lighter
  background: '#0d1117',        // Dark background (GitHub-style)
  surface: '#161b22',           // Dark cards/surfaces
  text: '#c9d1d9',              // Light gray text
  textSecondary: '#8b949e',     // Medium gray
  border: '#30363d',            // Dark gray borders
  shadow: 'rgba(0,0,0,0.4)',    // Stronger shadows
  navActive: '#21262d',         // Active nav background
  navActiveBorder: '#4dabf7',   // Active nav border
};
```

### Theme Toggle Implementation
```typescript
// ThemeContext.tsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';

type ThemeMode = 'light' | 'dark';

interface ThemeContextType {
  mode: ThemeMode;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export const useThemeMode = () => {
  const context = useContext(ThemeContext);
  if (!context) throw new Error('useThemeMode must be used within ThemeProvider');
  return context;
};

export const AppThemeProvider: React.FC<{children: React.ReactNode}> = ({ children }) => {
  // Check system preference or localStorage
  const [mode, setMode] = useState<ThemeMode>(() => {
    const saved = localStorage.getItem('theme-mode');
    if (saved) return saved as ThemeMode;
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  });

  // Save to localStorage when changed
  useEffect(() => {
    localStorage.setItem('theme-mode', mode);
    document.documentElement.classList.toggle('dark', mode === 'dark');
  }, [mode]);

  const toggleTheme = () => {
    setMode(prev => prev === 'light' ? 'dark' : 'light');
  };

  // Create MUI theme based on mode
  const theme = React.useMemo(() => 
    createTheme({
      palette: {
        mode,
        primary: {
          main: mode === 'light' ? '#0d6efd' : '#4dabf7',
        },
        background: {
          default: mode === 'light' ? '#f8f9fa' : '#0d1117',
          paper: mode === 'light' ? '#ffffff' : '#161b22',
        },
        text: {
          primary: mode === 'light' ? '#212529' : '#c9d1d9',
          secondary: mode === 'light' ? '#6c757d' : '#8b949e',
        },
      },
      typography: {
        fontFamily: 'Inter, sans-serif',
      },
    }), [mode]
  );

  return (
    <ThemeContext.Provider value={{ mode, toggleTheme }}>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        {children}
      </ThemeProvider>
    </ThemeContext.Provider>
  );
};
```

### Theme Toggle Button Component
```typescript
// components/ThemeToggle.tsx
import React from 'react';
import { IconButton } from '@mui/material';
import { useThemeMode } from '../theme/ThemeContext';
import Brightness4Icon from '@mui/icons-material/Brightness4';
import Brightness7Icon from '@mui/icons-material/Brightness7';

export const ThemeToggle: React.FC = () => {
  const { mode, toggleTheme } = useThemeMode();
  
  return (
    <IconButton
      onClick={toggleTheme}
      color="inherit"
      aria-label="toggle theme"
      className="transition-all duration-200"
    >
      {mode === 'dark' ? <Brightness7Icon /> : <Brightness4Icon />}
    </IconButton>
  );
};
```

### Tailwind Dark Mode Configuration
```javascript
// tailwind.config.js
module.exports = {
  darkMode: 'class', // Use class strategy for dark mode
  content: ['./src/**/*.{js,jsx,ts,tsx}'],
  theme: {
    extend: {
      colors: {
        // Light theme
        'light-bg': '#f8f9fa',
        'light-surface': '#ffffff',
        'light-text': '#212529',
        // Dark theme
        'dark-bg': '#0d1117',
        'dark-surface': '#161b22',
        'dark-text': '#c9d1d9',
      },
    },
  },
};
```

### Unified Component Styling Pattern
```typescript
// Every component should use this pattern for theme consistency
import { useTheme } from '@mui/material/styles';

export const ExampleComponent: React.FC = () => {
  const theme = useTheme();
  
  return (
    <div className={`
      bg-white dark:bg-dark-surface 
      text-gray-900 dark:text-dark-text
      border border-gray-200 dark:border-gray-700
      shadow-md dark:shadow-xl
      transition-colors duration-200
    `}>
      {/* Content */}
    </div>
  );
};
```

### Navigation Component (Matching Example)
```typescript
// components/Navigation.tsx
import React from 'react';
import { useTheme } from '@mui/material/styles';
import { ThemeToggle } from './ThemeToggle';

export const Navigation: React.FC = () => {
  const theme = useTheme();
  
  return (
    <nav className={`
      w-full md:w-64 
      ${theme.palette.mode === 'light' ? 'bg-white' : 'bg-dark-surface'}
      md:h-screen md:sticky md:top-0 
      border-b md:border-b-0 md:border-r 
      ${theme.palette.mode === 'light' ? 'border-gray-200' : 'border-gray-700'}
    `}>
      <div className="p-4 flex justify-between items-center">
        <div>
          <h1 className="text-xl font-bold text-primary">Learning Hub</h1>
          <p className="text-sm text-gray-500 dark:text-gray-400">Your Blockchain Guide</p>
        </div>
        <ThemeToggle />
      </div>
      {/* Navigation links */}
    </nav>
  );
};
```

## Component Templates

### Basic Component Template
```typescript
import React from 'react';
import { Box, Typography } from '@mui/material';

interface ComponentNameProps {
  title: string;
  onAction?: () => void;
}

/**
 * Brief description of what this component does
 */
export const ComponentName: React.FC<ComponentNameProps> = ({ 
  title, 
  onAction 
}) => {
  // Hooks
  const [state, setState] = React.useState<string>('');
  
  // Handlers
  const handleClick = () => {
    // Logic
    onAction?.();
  };
  
  // Render
  return (
    <Box className="p-4">
      <Typography variant="h5">{title}</Typography>
      {/* More content */}
    </Box>
  );
};
```

### Page Component Template
```typescript
import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Container, CircularProgress, Alert } from '@mui/material';

export const PageName: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const [data, setData] = useState<DataType | null>(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        // Fetch logic
        setLoading(false);
      } catch (err) {
        setError(err as Error);
        setLoading(false);
      }
    };
    
    fetchData();
  }, [id]);
  
  if (loading) return <CircularProgress />;
  if (error) return <Alert severity="error">{error.message}</Alert>;
  
  return (
    <Container className="py-8">
      {/* Page content */}
    </Container>
  );
};
```

## Anti-Patterns to Avoid

❌ **Avoid:**
- Using `any` type
- Inline styles (use MUI sx or Tailwind classes)
- Deeply nested components (max 3 levels)
- Props drilling (use context or composition)
- Direct DOM manipulation
- Missing error boundaries
- Hardcoded strings (use constants)
- Unused imports or variables

✅ **Do:**
- Explicit TypeScript types
- Consistent styling approach
- Flat component hierarchy
- Proper prop types
- React patterns
- Error boundaries for critical sections
- Internationalization-ready strings
- Clean, organized imports

## Testing Requirements

Every component should be testable:
```typescript
// ComponentName.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { ComponentName } from './ComponentName';

describe('ComponentName', () => {
  it('renders with title', () => {
    render(<ComponentName title="Test Title" />);
    expect(screen.getByText('Test Title')).toBeInTheDocument();
  });
  
  it('calls onAction when clicked', () => {
    const mockAction = jest.fn();
    render(<ComponentName title="Test" onAction={mockAction} />);
    fireEvent.click(screen.getByRole('button'));
    expect(mockAction).toHaveBeenCalled();
  });
});
```

## Performance Optimization

- Use `React.memo()` for expensive components
- Implement `useMemo()` for expensive calculations
- Use `useCallback()` for stable function references
- Lazy load routes with `React.lazy()`
- Optimize images (WebP format, proper sizing)
- Code splitting for large modules

## Documentation

Include JSDoc comments for:
- Complex logic
- Reusable utilities
- Custom hooks
- Type definitions

```typescript
/**
 * Formats a date string to a readable format
 * @param date - ISO date string
 * @returns Formatted date (e.g., "Oct 31, 2025")
 */
export const formatDate = (date: string): string => {
  // Implementation
};
```

---

When building components, always ask yourself:
1. Is this component reusable?
2. Are all types explicit?
3. Is it accessible?
4. Does it handle loading and error states?
5. Is it responsive?
6. Can it be tested easily?
