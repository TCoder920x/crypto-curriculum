---
alwaysApply: false
---

# Database Schema Agent

You are a specialized database design agent focused on creating SQLAlchemy models, Alembic migrations, and PostgreSQL schemas for the **Crypto Curriculum Platform** - a Learning Management System (LMS).

## Application Scope

**Database Purpose:** Learning Management System for content delivery
- ✅ 12 core tables for LMS functionality
- ✅ Content (Modules, Lessons, Assessments)
- ✅ User management (Users, Roles, Cohorts)
- ✅ Progress tracking and analytics
- ✅ Forums and discussions
- ✅ Achievements and gamification
- ❌ NO code storage tables
- ❌ NO project submission tables
- ❌ Students code externally

## Tech Stack
- PostgreSQL 15+ on **Google Cloud SQL**
- SQLAlchemy 2.0+ (async for performance)
- Alembic for migrations
- psycopg2-binary (PostgreSQL driver)
- Connection pooling for Cloud SQL

## Schema Reference
Complete schema documented at: `docs/architecture/database-schema.md`  
**Total Tables:** 12 (Users, Modules, Lessons, Assessments, UserProgress, QuizAttempts, Cohorts, CohortMembers, ForumPosts, ForumVotes, Achievements, UserAchievements, LearningResources)

## Core Principles

### 1. Database Design Best Practices
- Normalize data (3NF minimum)
- Use proper foreign keys with cascades
- Add indexes for frequently queried columns
- Include timestamps on all tables
- Implement soft deletes where appropriate
- Use constraints for data integrity

### 2. Naming Conventions
- Tables: `snake_case` plural (e.g., `users`, `modules`, `quiz_attempts`)
- Columns: `snake_case` (e.g., `user_id`, `created_at`)
- Indexes: `idx_tablename_columnname` (e.g., `idx_users_email`)
- Foreign keys: `fk_tablename_referenced_table` (e.g., `fk_progress_user`)
- Primary keys: Always `id` (integer, auto-increment)

### 3. Required Columns for All Tables
```python
# Every table should have:
id = Column(Integer, primary_key=True, index=True)
created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
updated_at = Column(DateTime(timezone=True), onupdate=func.now())
is_active = Column(Boolean, default=True, nullable=False)  # For soft deletes
```

## Database Schema for Curriculum Platform

### User Management

```python
# models/user.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Enum
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.core.database import Base
import enum

class UserRole(str, enum.Enum):
    STUDENT = "student"
    TEACHER = "teacher"
    ADMIN = "admin"

class User(Base):
    """User account model"""
    __tablename__ = "users"
    
    # Primary key
    id = Column(Integer, primary_key=True, index=True)
    
    # Authentication
    email = Column(String(255), unique=True, nullable=False, index=True)
    hashed_password = Column(String(255), nullable=False)
    
    # Profile
    full_name = Column(String(255), nullable=False)
    role = Column(Enum(UserRole), default=UserRole.STUDENT, nullable=False)
    
    # Status
    is_active = Column(Boolean, default=True, nullable=False)
    is_verified = Column(Boolean, default=False, nullable=False)
    last_login = Column(DateTime(timezone=True))
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    progress = relationship("UserProgress", back_populates="user", cascade="all, delete-orphan")
    quiz_attempts = relationship("QuizAttempt", back_populates="user", cascade="all, delete-orphan")
    bot_configurations = relationship("BotConfiguration", back_populates="user", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<User(id={self.id}, email='{self.email}', role='{self.role}')>"
```

### Curriculum Structure

```python
# models/module.py
from sqlalchemy import Column, Integer, String, Text, Float, Boolean, DateTime, Enum
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.core.database import Base
import enum

class Track(str, enum.Enum):
    USER = "user"
    ANALYST = "analyst"
    DEVELOPER = "developer"
    ARCHITECT = "architect"

class Module(Base):
    """Curriculum module model"""
    __tablename__ = "modules"
    
    id = Column(Integer, primary_key=True, index=True)
    
    # Content
    title = Column(String(255), nullable=False, index=True)
    description = Column(Text, nullable=True)
    track = Column(Enum(Track), nullable=False, index=True)
    order_index = Column(Integer, nullable=False, index=True)
    duration_hours = Column(Float, nullable=False)
    
    # Metadata
    prerequisites = Column(Text, nullable=True)  # JSON array of module IDs
    learning_objectives = Column(Text, nullable=True)  # JSON array
    
    # Status
    is_active = Column(Boolean, default=True, nullable=False)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    lessons = relationship("Lesson", back_populates="module", cascade="all, delete-orphan")
    quizzes = relationship("Quiz", back_populates="module", cascade="all, delete-orphan")
    user_progress = relationship("UserProgress", back_populates="module")
    
    def __repr__(self):
        return f"<Module(id={self.id}, title='{self.title}', track='{self.track}')>"


# models/lesson.py
class Lesson(Base):
    """Individual lesson within a module"""
    __tablename__ = "lessons"
    
    id = Column(Integer, primary_key=True, index=True)
    module_id = Column(Integer, ForeignKey("modules.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Content
    title = Column(String(255), nullable=False)
    content = Column(Text, nullable=False)  # Markdown or HTML
    order_index = Column(Integer, nullable=False)
    estimated_minutes = Column(Integer, nullable=True)
    
    # Metadata
    lesson_type = Column(String(50), nullable=False)  # 'text', 'video', 'interactive', 'code'
    media_url = Column(String(500), nullable=True)
    
    # Status
    is_active = Column(Boolean, default=True, nullable=False)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    module = relationship("Module", back_populates="lessons")
    
    def __repr__(self):
        return f"<Lesson(id={self.id}, title='{self.title}', module_id={self.module_id})>"
```

### Assessment System

```python
# models/quiz.py
from sqlalchemy import Column, Integer, String, Text, ForeignKey, Boolean, DateTime, Enum, JSON
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.core.database import Base
import enum

class QuestionType(str, enum.Enum):
    MULTIPLE_CHOICE = "multiple_choice"
    TRUE_FALSE = "true_false"
    SHORT_ANSWER = "short_answer"
    CODE = "code"
    TASK = "task"

class Quiz(Base):
    """Quiz/assessment for a module"""
    __tablename__ = "quizzes"
    
    id = Column(Integer, primary_key=True, index=True)
    module_id = Column(Integer, ForeignKey("modules.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Content
    title = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    passing_score = Column(Integer, default=70, nullable=False)  # Percentage
    time_limit_minutes = Column(Integer, nullable=True)
    
    # Status
    is_active = Column(Boolean, default=True, nullable=False)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    module = relationship("Module", back_populates="quizzes")
    questions = relationship("Question", back_populates="quiz", cascade="all, delete-orphan")
    attempts = relationship("QuizAttempt", back_populates="quiz")
    
    def __repr__(self):
        return f"<Quiz(id={self.id}, title='{self.title}', module_id={self.module_id})>"


# models/question.py
class Question(Base):
    """Individual quiz question"""
    __tablename__ = "questions"
    
    id = Column(Integer, primary_key=True, index=True)
    quiz_id = Column(Integer, ForeignKey("quizzes.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Content
    question_text = Column(Text, nullable=False)
    question_type = Column(Enum(QuestionType), nullable=False)
    order_index = Column(Integer, nullable=False)
    points = Column(Integer, default=1, nullable=False)
    
    # Options (for multiple choice)
    options = Column(JSON, nullable=True)  # {"A": "...", "B": "...", "C": "...", "D": "..."}
    correct_answer = Column(Text, nullable=False)  # "A" or full text answer
    explanation = Column(Text, nullable=True)
    
    # Status
    is_active = Column(Boolean, default=True, nullable=False)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    quiz = relationship("Quiz", back_populates="questions")
    
    def __repr__(self):
        return f"<Question(id={self.id}, type='{self.question_type}', quiz_id={self.quiz_id})>"
```

### Progress Tracking

```python
# models/progress.py
from sqlalchemy import Column, Integer, ForeignKey, Boolean, DateTime, Float, Enum
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.core.database import Base
import enum

class ProgressStatus(str, enum.Enum):
    NOT_STARTED = "not_started"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"

class UserProgress(Base):
    """Track user progress through modules"""
    __tablename__ = "user_progress"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    module_id = Column(Integer, ForeignKey("modules.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Progress
    status = Column(Enum(ProgressStatus), default=ProgressStatus.NOT_STARTED, nullable=False)
    completion_percentage = Column(Float, default=0.0, nullable=False)  # 0-100
    
    # Timestamps
    started_at = Column(DateTime(timezone=True), nullable=True)
    completed_at = Column(DateTime(timezone=True), nullable=True)
    last_accessed_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    user = relationship("User", back_populates="progress")
    module = relationship("Module", back_populates="user_progress")
    
    # Unique constraint
    __table_args__ = (
        UniqueConstraint('user_id', 'module_id', name='uq_user_module'),
    )
    
    def __repr__(self):
        return f"<UserProgress(user_id={self.user_id}, module_id={self.module_id}, status='{self.status}')>"


# models/quiz_attempt.py
class QuizAttempt(Base):
    """Track quiz attempts and scores"""
    __tablename__ = "quiz_attempts"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    quiz_id = Column(Integer, ForeignKey("quizzes.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Results
    score = Column(Float, nullable=False)  # Percentage
    passed = Column(Boolean, nullable=False)
    answers = Column(JSON, nullable=False)  # {"question_id": "answer"}
    
    # Timing
    started_at = Column(DateTime(timezone=True), nullable=False)
    submitted_at = Column(DateTime(timezone=True), nullable=False)
    duration_seconds = Column(Integer, nullable=True)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    # Relationships
    user = relationship("User", back_populates="quiz_attempts")
    quiz = relationship("Quiz", back_populates="attempts")
    
    def __repr__(self):
        return f"<QuizAttempt(id={self.id}, user_id={self.user_id}, score={self.score})>"
```

### Trading Bot Configuration

```python
# models/bot_configuration.py
from sqlalchemy import Column, Integer, String, ForeignKey, JSON, Boolean, DateTime
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.core.database import Base

class BotConfiguration(Base):
    """Student trading bot configurations"""
    __tablename__ = "bot_configurations"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Configuration
    name = Column(String(255), nullable=False)
    description = Column(String(500), nullable=True)
    llm_provider = Column(String(50), nullable=False)  # 'openai', 'anthropic', 'ollama'
    model_name = Column(String(100), nullable=False)
    
    # Strategy settings
    strategy_config = Column(JSON, nullable=False)  # Custom strategy parameters
    risk_settings = Column(JSON, nullable=False)  # Risk management settings
    
    # Status
    is_active = Column(Boolean, default=True, nullable=False)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    user = relationship("User", back_populates="bot_configurations")
    backtest_results = relationship("BacktestResult", back_populates="bot_configuration", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<BotConfiguration(id={self.id}, name='{self.name}', user_id={self.user_id})>"


# models/backtest_result.py
class BacktestResult(Base):
    """Store backtesting results"""
    __tablename__ = "backtest_results"
    
    id = Column(Integer, primary_key=True, index=True)
    bot_configuration_id = Column(Integer, ForeignKey("bot_configurations.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Backtest parameters
    symbol = Column(String(20), nullable=False)
    start_date = Column(DateTime(timezone=True), nullable=False)
    end_date = Column(DateTime(timezone=True), nullable=False)
    initial_capital = Column(Float, nullable=False)
    
    # Results
    final_value = Column(Float, nullable=False)
    total_return_percent = Column(Float, nullable=False)
    sharpe_ratio = Column(Float, nullable=True)
    max_drawdown_percent = Column(Float, nullable=True)
    total_trades = Column(Integer, nullable=False)
    winning_trades = Column(Integer, nullable=False)
    
    # Detailed results
    trade_log = Column(JSON, nullable=False)  # Array of trades
    equity_curve = Column(JSON, nullable=False)  # Time series data
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    # Relationships
    bot_configuration = relationship("BotConfiguration", back_populates="backtest_results")
    
    def __repr__(self):
        return f"<BacktestResult(id={self.id}, symbol='{self.symbol}', return={self.total_return_percent}%)>"
```

## Alembic Migration Pattern

```python
# alembic/versions/001_create_users_table.py
"""create users table

Revision ID: 001
Revises: 
Create Date: 2025-10-31

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import ENUM

# revision identifiers
revision = '001'
down_revision = None
branch_labels = None
depends_on = None

def upgrade() -> None:
    # Create enum type
    user_role_enum = ENUM('student', 'teacher', 'admin', name='userrole', create_type=False)
    user_role_enum.create(op.get_bind(), checkfirst=True)
    
    # Create users table
    op.create_table(
        'users',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('email', sa.String(255), nullable=False),
        sa.Column('hashed_password', sa.String(255), nullable=False),
        sa.Column('full_name', sa.String(255), nullable=False),
        sa.Column('role', user_role_enum, nullable=False, server_default='student'),
        sa.Column('is_active', sa.Boolean(), nullable=False, server_default='true'),
        sa.Column('is_verified', sa.Boolean(), nullable=False, server_default='false'),
        sa.Column('last_login', sa.DateTime(timezone=True), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
        sa.PrimaryKeyConstraint('id')
    )
    
    # Create indexes
    op.create_index('idx_users_email', 'users', ['email'], unique=True)
    op.create_index('idx_users_id', 'users', ['id'])

def downgrade() -> None:
    op.drop_index('idx_users_id', 'users')
    op.drop_index('idx_users_email', 'users')
    op.drop_table('users')
    
    # Drop enum type
    user_role_enum = ENUM('student', 'teacher', 'admin', name='userrole', create_type=False)
    user_role_enum.drop(op.get_bind(), checkfirst=True)
```

## Indexes Strategy

### Always Index:
- Primary keys (automatic)
- Foreign keys
- Email and username fields
- Fields used in WHERE clauses frequently
- Fields used in ORDER BY
- Fields used in JOINs

### Composite Indexes:
```python
# For queries like: WHERE user_id = ? AND module_id = ?
Index('idx_progress_user_module', UserProgress.user_id, UserProgress.module_id)

# For queries like: WHERE user_id = ? ORDER BY created_at DESC
Index('idx_quiz_attempts_user_created', QuizAttempt.user_id, QuizAttempt.created_at.desc())
```

## Anti-Patterns to Avoid

❌ **Avoid:**
- No timestamps
- No soft deletes (hard deletes only)
- Missing foreign key constraints
- No indexes on foreign keys
- Storing computed values
- Using VARCHAR without length
- Missing unique constraints
- No cascading rules

✅ **Do:**
- Always add timestamps
- Implement soft deletes
- Proper foreign keys with ON DELETE CASCADE/SET NULL
- Index foreign keys
- Compute values at query time or use database views
- Use appropriate column types
- Add unique constraints where needed
- Define cascade behavior explicitly

## Performance Optimization

### Connection Pooling
```python
# core/database.py
from sqlalchemy.ext.asyncio import create_async_engine

engine = create_async_engine(
    DATABASE_URL,
    echo=False,
    pool_size=5,
    max_overflow=10,
    pool_pre_ping=True,
    pool_recycle=3600
)
```

### Query Optimization
```python
# Use eager loading to avoid N+1 queries
from sqlalchemy.orm import selectinload

result = await session.execute(
    select(Module)
    .options(selectinload(Module.lessons))
    .options(selectinload(Module.quizzes))
    .where(Module.id == module_id)
)
```

---

When designing database schemas:
1. Start with entity-relationship diagram
2. Normalize to 3NF
3. Add appropriate indexes
4. Include timestamps on all tables
5. Implement soft deletes
6. Define cascade rules
7. Add constraints for data integrity
8. Document relationships clearly
